#BEGIN_PROPERTIES#
{
    "commandsIntroduced": ["map.getAdjacentEmptyCells"]
}
#END_PROPERTIES#
/*
 * robotMaze.js
 *
 * The blue key is inside a labyrinth, and extracting
 * it will not be easy.
 *
 * It's a good thing that you're a AI expert, or
 * we would have to leave empty-handed.
 */

function getRandomInt(min, max) {
    return Math.floor(Math.random() * (max - min + 1)) + min;
}

function startLevel(map) {
    map.placePlayer(map.getWidth()-2, map.getHeight()-2);

    map.defineObject('robot', {
        'type': 'dynamic',
        'symbol': 'R',
        'color': 'gray',
        'onCollision': function (player, me) {
            me.giveItemTo(player, 'blueKey');
        },
        'behavior': function (me) {
#BEGIN_EDITABLE#
          if (me.pathFound) {
             if (me.pathFound.length > 0) {
                me.move(me.pathFound.shift());
             } else {
                me.move('down');
             }
          } else {
             me.pathFound = [];
             exploredSet = [];
             frontier = [[[1, 1], []]];
             frontierSet = ["1,1"];
             for (var j=0; j<500; j++) {
                node = frontier.shift(); frontierSet.shift();
                state = node[0];
                exploredSet.push(state.toString());
                var moves = map.getAdjacentEmptyCells(state[0], state[1]);
                for (var i = 0; i < moves.length; i++) {
                  var move = moves[i];
                  var child = move[0];
                  var direction = move[1];
                  if (exploredSet.indexOf(child.toString()) == -1 &&
                  frontierSet.indexOf(child.toString()) == -1) {
                    path = node[1].slice(0);
                    path.push(direction);
                    frontier.push([child, path.slice(0)]);
                    frontierSet.push(child.toString());
                    if (child[0] == map.getWidth() - 2 && child[1] == 7) {
                        me.pathFound = path;
                        me.done = true;
                        break;
                    }
                  }
                }
                if (me.done) {
                    break;
                }
             }
          }




#END_EDITABLE#
        }
    });

    map.defineObject('barrier', {
        'symbol': 'â–‘',
        'color': 'purple',
        'impassable': true,
        'passableFor': ['robot']
    });

    map.placeObject(0, map.getHeight() - 1, 'exit');
    map.placeObject(1, 1, 'robot');
    map.placeObject(map.getWidth() - 2, 8, 'blueKey');
    map.placeObject(map.getWidth() - 2, 9, 'barrier');

    var autoGeneratedMaze = new ROT.Map.DividedMaze(map.getWidth(), 10);
    autoGeneratedMaze.create( function (x, y, mapValue) {
        // don't write maze over robot or barrier
        if ((x == 1 && y == 1) || (x == map.getWidth() - 2 && y >= 8)) {
            return 0;
        } else if (mapValue === 1) { //0 is empty space 1 is wall
            map.placeObject(x,y, 'block');
        } else {
            map.placeObject(x,y,'empty');
        }
    });
}

function validateLevel(map) {
    map.validateExactlyXManyObjects(1, 'exit');
    map.validateExactlyXManyObjects(1, 'robot');
    map.validateAtMostXObjects(1, 'blueKey');
}

function onExit(map) {
    if (!map.getPlayer().hasItem('blueKey')) {
        map.writeStatus("We need to get that key!");
        return false;
    } else {
        return true;
    }
}
